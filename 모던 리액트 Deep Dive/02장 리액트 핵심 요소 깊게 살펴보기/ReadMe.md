## 2.1 JSX란

- xml과 유사한 내장형 구문
- 리액트에 종속적이지 않은 독자적인 문법

### JSX의 정의

- JSXElement
  - JSX 를 구성하는 가장 기본 요소
  - HTML의 요소(element)와 비슷한 역할
  - JSXOpeningElement: < ~~ >
  - JSXClosingElement: </ ~~>
  - JSXSelfClosingElement: < ~~ />
  - JSXFragment: <> ~~~ </>
- JSXAttributes
  - JSXElement에 부여할 수 있는 속성
  - 필수값 X
- JSXChildren
  - JSXElement의 자식 값
- JSXStrings

## 2.2 가상 DOM과 리액프 파이버

실제 DOM이 아닌 가상 DOM을 운영한다는 것

### DOM과 브라우저 렌더링 과정

**DOM**

- 웹페이지에 대한 인터페이스
- 브라우저가 웹페이지의 콘텐츠와 구조를 어떻게 보여줄지에 대한 정보를 담음

브라우저가 웹사이트 접근 요청을 받고 화면을 그리는 과정

1. 사용자가 요청한 주소에서 HTML 파일 다운로드
2. 브라우저 렌더링 엔진은 HTML을 파싱해 DOM 노드로 구성된 트리(DOM) 생성
3. css 파일 다운로드
4. CSS 노드로 구성된 트리(CSSOM) 생성
5. 브라우저는 DOM 노드 순회(사용자 눈에 보이는 것만)
6. 눈에 보이는 노드에 대한 CSSOM 정보 찾기
7. 발견한 CSS 스타일 정보 DOM 노드에 적용
   - 레이아웃: 각 노드가 브라우저 화면의 어느 좌표에 정확히 나타나야 하는지 계산
   - 페인팅: 레이아웃 단계를 거친 노드에 실제 유효한 모습을 그리는 과정

### 가상 DOM 탄생 배경

DOM 변경이 일어나는 요소가 많은 자식 요소를 가지고 있으면 하위 자식 요소가 덩달아 변경되기 때문에 많은 비용 발생

**가상DOM**: 웹페이지가 표시해야 할 DOM을 일단 메모리에 저장하고 리액트가 실제 변경에 대한 준비가 완료되었을때 실제 브라우저의 DOM에 반영

→ 여러번 발생할 렌더링 과정 최소화

→ 브라우저와 개발자 부담 감소

### 가상 DOM을 위한 아키텍처, 리액트 파이버

**리액트 파이버**

- 가상 DOM과 렌더링 과정 최적화를 가능하게 해주는 것
- 가상 DOM과 실제 DOM을 비교해 변경 사항을 수집하여 차이가 있으면 변경에 관련된 정보를 가지고 있는 파이버를 기준으로 화면에 렌더링을 요청하는 역할

> 어떤 부분을 새롭게 렌더링해야 하는지 가상 DOM과 실제 DOM을 비교하는 작업

**리액트 파이버의 목표**

: 리액트 웹 애플리케이션에서 발생하는 애니메이션, 레이아웃, 사용자 인터랙션에 올바른 결과물을 만드는 반응성 문제를 해결하는 것

**파이버가 하는 일**

- 작업을 작은 단위로 분할하고 쪼갠 다음 우선순위 매기기
- 이런 작업 일시중지하고 나중에 다시 시작 가능
- 이전에 했던 작업 다시 재사용하거나 필요하지 않은 경우 폐기

⇒ 모든 과정이 비동기로 발생

(기존 렌더링 스택의 비효율성을 해결하기 위해 제작)

리액트 요소와 파이버의 차이

- **리액트 요소**: 렌더링이 발생할때마다 새롭게 생성
- **파이버**: 가급적이면 재사용

> 📌 가상 DOM과 리액트의 핵심은 브라우저의 **DOM을 바로 값으로 UI를 표현**하는 것

## 2.3 클래스 컴포넌트와 함수 컴포넌트

함수 컴포넌트에 **훅**이 등장한 이후 함수 컴포넌트에서 상태나 생명주기 메서드 비슷한 작업을 흉내 낼 수 있게 되자 상대적으로 보일러플레이트가 복잡한 클래스 컴포넌트보다 함수 컴포넌트를 더 많이 쓰기 시작했다.

- 보일러플레이트
  → 클래스 컴포넌트에서 반복적으로 작성해야 하는 코드 구조
  클래스 컴포넌트는 함수 컴포넌트보다 더 많은 기본 구조와 설정이 필요 → 이를 보일러플레이트

### 클래스 컴포넌트

클래스 컴포넌트의 한계

- 데이터 흐름을 추적하기 어렵다
- 애플리케이션 내부 로직의 재사용이 어렵다
- 기능이 많아질수록 컴포넌트의 크기가 커진다
- 클래스는 함수에 비해 상대적으로 어렵다
- 코드 크기를 최적화하기 어렵다

### 함수 컴포넌트

- 생명주기 메서드 X
  - useEffect 훅을 사용하여 비슷하게 구현 가능
- 렌더링된 값 고정

## 2.4 렌더링은 어떻게 일어나는가?

**브라우저**에서의 렌더링: HTML과 CSS 리소스를 기반으로 웹페이지에 필요한 UI 그리기

**리액트**의 렌더링: 브라우저가 렌더링에 필요한 DOM 트리를 만드는 과정

### 리액트의 렌더링

리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이

현재 자신들이 가지고 있는 props와 state의 값을 기반으로

어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 과정

### 리액트의 렌더링이 일어나는 이유

리액트 렌더링 발생 시나리오

1. 최초 렌더링
   - 리액트는 브라우저에 처음 애플리케이션 진입을 위한 렌더링 결과물 제공을 위해 수행
2. 리렌더링
   - 최초 렌더링이 발생한 이후로 발생하는 모든 렌더링
   - 리렌더링이 발생하는 상황
     - useState()의 setter 가 실행되는 경우
     - useRender()의 dispatch가 실행되는 경우
     - 컴포넌트의 key props가 변경되는 경우
     - props가 변경되는 경우
     - 부모 컴포넌트가 렌더링될 경우 (자식도 무조건 리렌더링)
   - useState등으로 관리되지 않는 단순한 변수는 아무리 변경된다 해도 리렌더링 X

### **리액트 렌더링 프로세스**

렌더링 프로세스가 시작되면

1. 컴포넌트 루트에서부터 아래로 내려가면서 업데이트가 필요하다고 지정된 컴포넌트 찾기
2. 업데이트가 필요한 컴포넌트는
   - 클래스 컴포넌트: 클래스 내부의 render() 함수 실행
   - 함수 컴포넌트: FunctionComponent() 자체 호출한 뒤 결과물 저장

### 렌더와 커밋

- 렌더 단계
  - 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업
  - 결과와 이전 가상 DOM을 비교하여 변경이 필요한 컴포넌트 체크
  - type, props, key 비교
- 커밋 단계
  - 렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정

⇒ 리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는 것은 아니다

## 2.5 컴포넌트와 함수의 무거운 연산을 기억해두는 메모이제이션

무조건 메모이제이션이 필요한가 vs 메모이제이션을 섣불리 해서는 안 된다

### 꼭 필요한 곳에만 메모이제이션을 추가하자

메모이제이션도 비용이 드는 작업.

- 값을 비교하고 렌더링 또는 재계산이 필요한지 확인하는 작업
- 이전 결과물을 저장해두었다가 다시 꺼내는 작업

이전 결과를 캐시로 저장해 미래에 더 나은 성능을 위해 메모리를 차례대로 점유

→ 메모리에 저장하는것도 마찬가지로 비용

### 모조리 메모이제이션 하자

자식 컴포넌트를 많이 가지고 있으면 이점이 있을수도

- memo를 컴포넌트의 사용에 따라 잘 살펴보고 일부에만 적용
- memo를 일단 그냥 다 적용

잘못된 memo로 지불해야하는 비용

→ props에 대한 얕은 비교가 발생하면서 지불해야하는 비용

리액트의 기본적인 알고리즘 때문에 이전 결과물은 저장해두고 있다

memo를 하지 않았을때 발생할 수 있는 문제

- 렌더링을 함으로써 발생하는 비용
- 컴포넌트 내부의 복잡한 로직의 재실행
- 위 두가지 모두가 모든 자식 컴포넌트에서 반복해서 발생
- 리액트가 구트리와 신규트리를 비교

**조금이라도 로직이 들어간** 컴포넌트는 메모이제이션이 성능 향상에 도움을 줄 가능성이 크다

그렇다면 로직이 들어간 정도의 기준은 무엇인가

- 복잡한 계산: 컴포넌트 내에서 복잡한 수학적 연사니나 데이터 처리가 이루어지면
- 반복적인 렌더링: 부모 컴포넌트는 자주 렌더링되는데, 자식 컴포넌트의 props가 변경되지 않는 경우
- 큰 데이터셋 처리: 대량의 데이터를 필터링하거나 정렬하는 작업
- 비용이 많이 드는 함수 호출
  - API 호출
  - 복잡한 DOM 조작
- 렌더링 시간
